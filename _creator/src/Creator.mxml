<?xml version="1.0" encoding="utf-8"?>
<materia:CreatorBase xmlns:mx="http://www.adobe.com/2006/mxml"
                     xmlns:materia="materia.*"
                     xmlns:questionanswerdatagrid="materia.components.questionAnswerDataGrid.*"
                     layout="absolute"
                     width="100%" height="100%">
	<mx:Style>
		.wordSearchText
		{
			fontSize:14;
			font-weight:normal;
			color: #ffffff;
		}
	</mx:Style>

	<mx:VBox top="5" bottom="5" left="5" right="5">
		<mx:Canvas height="50" width="100%">
			<mx:HBox left="5" right="5" height="40" verticalCenter="0" verticalAlign="middle">
				<mx:Label text="Widget Title: " styleName="sectionLabel"/>
				<mx:TextInput height="40" id="gameTitle" text="{instanceTitle}" maxChars="{CreatorConfig.MAX_TITLE_LENGTH}" change="{instanceTitle=gameTitle.text;}" width="100%" styleName="titleField"/>
			</mx:HBox>
		</mx:Canvas>
		<mx:HBox horizontalGap="10" bottom="5" right="10" left="10" top="58" id="hbox1" width="100%" height="100%" styleName="creatorSectionMajor">
			<!-- Terms -->
			<mx:Canvas width="375" height="100%" styleName="creatorSectionMinor">
				<mx:Canvas left="10" right="10" top="10">
					<mx:Label text="Terms:" styleName="sectionLabel" left="0" top="0"/>
					<mx:HBox right="0" visible="false">
						<mx:Label id="currentTermsLabel" />
						<mx:Button id="toggleTermsButton" label="Change Style" click="{toggleEntryMode();}"/>
					</mx:HBox>
				</mx:Canvas>
				<mx:VBox id="gameTypeExplanationVBox" width="100%" top="46" bottom="20" left="10">
						<mx:Text styleName="wordSearchText" top="10" left="10" bottom="10" right="10" selectable="false"
							text="Select the type of word search to make."  width="100%"/>
					<mx:HRule width="100%"/>
					<mx:LinkButton color="#FFCF09" label="Term" click="{enterByTerms()}"/>
					<mx:Text styleName="wordSearchText" top="10" left="10" bottom="10" right="10"
						text="You will input a list of terms which students will search for in the letters grid."
						selectable="false" width="100%"/>
					<mx:HRule width="100%"/>
					<mx:LinkButton color="#FFCF09" label="Definition" click="{enterByDefinition()}"/>
						<mx:Text styleName="wordSearchText" top="10" left="10" bottom="10" right="10"
							text="You will input a list of terms with their definitions. Students will search for the terms, given their definitions."
							selectable="false" width="100%"/>
				</mx:VBox>
				<!-- Custom Datagrid -->
				<questionanswerdatagrid:QuestionAnswerDataGrid 	id="questionsDataGrid"
																top="43"
																bottom="10"
																right="10"
																left="10"
																visible="true"
																characterLimit="20"
																restrict="{restrict}"
																dataProvider="{_questionData}"
																answerExplanationText="Enter a term here"
																multilineFields="false"
																/>
			</mx:Canvas>
			<!-- Right Side -->
			<mx:Canvas width="100%" height="100%" styleName="creatorSectionMinor">
				<mx:VBox horizontalAlign="center" left="10" right="10"
						   bottom="10" top="10">
					<mx:Label text="Puzzle Preview:" styleName="sectionLabel"/>
					<mx:Canvas id="sWFBackgroundCanvas" backgroundColor="#272727" backgroundAlpha="1.0"
						width="100%"
						height="100%"
						horizontalCenter="0"
						verticalCenter="0" cornerRadius="12" borderStyle="solid">
						<mx:SWFLoader id="wordSearchSWFLoader"
						height="{Math.min(sWFBackgroundCanvas.width, sWFBackgroundCanvas.height) - 20}" width="{Math.min(sWFBackgroundCanvas.width, sWFBackgroundCanvas.height) - 20}" horizontalCenter="0" verticalCenter="0"/>
					</mx:Canvas>
					<mx:Button label="Regenerate" click="{generatePuzzleDisplay();}" id="btnGenerate" styleName="gameButton" width="130"/>
					<mx:Spacer width="10" height="10" />
					<mx:Label text="Options:" styleName="sectionLabel"/>
					<mx:HRule width="100%" strokeColor="#9198B3" strokeWidth="1"/>
					<mx:VBox verticalAlign="middle">
						<mx:HBox>
							<mx:CheckBox id="backwardsCheckBox"
								selected="true"
								change="{backwardsCheckBoxChecked()}"
								verticalCenter="0"/>
							<mx:Text styleName="wordSearchText" text="Words Can Be Backwards" selectable="false"/>
						</mx:HBox>
						<mx:HBox>
							<mx:CheckBox id="diagonalCheckBox"
								selected="true"
								change="{diagonalCheckBoxChecked()}"/>
							<mx:Text styleName="wordSearchText" text="Words Can Be Diagonal" selectable="false"/>
						</mx:HBox>
						<mx:HBox id="randomGenHBox" visible="false" width="1" height="1">
							<mx:CheckBox id="randomCheckBox" selected="false" change="{randomBoxChecked()}"/>
							<mx:Text styleName="wordSearchText" text="Generate Different Puzzle Every Time" selectable="false"/>
						</mx:HBox>
					</mx:VBox>
				</mx:VBox>
				<!-- Check Boxes -->
			</mx:Canvas>
				<!-- END right side -->
		</mx:HBox>
	</mx:VBox>
	<mx:Script>
		<![CDATA[
		import materia.CreatorConfig;
		import materia.CreatorEvents;
		import materia.questionStorage.Question;
		import materia.questionStorage.QuestionGroup;
		import materia.questionStorage.QuestionSet;
		import mx.collections.ArrayCollection;
		import mx.controls.Alert;
		import mx.events.DataGridEvent;
		import mx.events.FlexEvent;
		[Bindable]
		protected var _questionData:ArrayCollection = new ArrayCollection();
		protected var _wordSearchGameData:WordSearchLogic;
		protected var _wordSearchGameDisplay:WordSearchDisplay;
		[Bindable]
		protected var _isGameTypeSelected:Boolean = false;
		[Bindable]
		protected var _isEnterByDefinition:Boolean = false;
		protected var _currentEntryMode:int = 0;
		protected var _listDataChanged:Boolean = false;
		protected var _refreshTimer:Timer;
		protected var _puzzleGenerated:Boolean = false;
		/**
		 * Override the base question type for the qaDataGrid
		 **/
		QUESTION_TYPE = 'WordSearchQuestion';
		WordSearchQuestion;
		
			//[Bindable]
		//protected var restrict:String = "a-zA-Z0-9 "; //Gets rid of the 'CTRL+A bug
		//--------------------------------------------------------------------------
		//
		//  Overridden Methods
		//
		//--------------------------------------------------------------------------
		/**
		 *	init.
		 */
		override public function init():void
		{
			restrict = 'a-zA-Z0-9 ';
			multilineFields = false;
			//Disable publish when page loads
			this.dispatchEvent(new Event(CreatorEvents.DISABLE_PUBLISH, true));
			btnGenerate.enabled = false
			// customize datagrid
			questionsDataGrid.answerHeaderLabel = "Word Search Terms";
			questionsDataGrid.questionColumn.editable = false;
			questionsDataGrid.questionColumn.visible = false;
			questionsDataGrid.addEventListener(DataGridEvent.ITEM_EDIT_END, onItemEditEnd, false, 0, true);
			questionsDataGrid.addEventListener(FlexEvent.DATA_CHANGE, onListDataChanged, false, 0, true);
			// timer for detecting word changes
			_refreshTimer = new Timer(1500, 1);
			_refreshTimer.addEventListener(TimerEvent.TIMER_COMPLETE, generatePuzzleDisplay);
			super.init();
			enterByTerms();
			//Disable randomizing until we can make all games usable
			randomGenHBox.visible = false;
			instanceTitle = 'New Word Search Widget';
		}
		public override function initNewWidget(widget:Object, baseUrl:String):void
		{
			super.initNewWidget(widget, baseUrl);
			questionsDataGrid.addQuestion(null, false);
		}
		/**
		 *	When loading a game to edit
		 */
		protected override function initExistingWidget(title:String, widget:Object, qset:Object, version:String, baseUrl:String):void
		{
			super.initExistingWidget(title, widget, qset, version, baseUrl);
			//enable publish button for edited games
			dispatchEvent(new Event(CreatorEvents.ENABLE_PUBLISH, true));

			var questions:Array

			// For old qset structures
			if(questionSet.items.length > 0 && questionSet.items[0].hasOwnProperty('items'))
			{
				questions = questionSet.items[0].items;
			}
			// new qset structure
			else
			{
				questions = questionSet.items;
			}

			var i:int;
			for (i = 0; i < questions.length; i++)
			{
				questionsDataGrid.addQuestion(questions[i], false, false);
			}
			// add the game options
			backwardsCheckBox.selected = questionSet.options.backwards == "1";
			diagonalCheckBox.selected = questionSet.options.diagonal == "1";
			randomCheckBox.selected = questionSet.options.random == "1";
			_isEnterByDefinition = questionSet.options.byDefinitions == "1";
			if (_isEnterByDefinition == true)
			{
				enterByDefinition();
			}
			else
			{
				enterByTerms();
			}
			if (randomCheckBox.selected == false)
			{
				// we should have a puzzle saved that we can re-make
				_wordSearchGameData = new WordSearchLogic(1, 1, diagonalCheckBox.selected, backwardsCheckBox.selected);
				_wordSearchGameData.loadPuzzle(questionSet.options["puzzleWidth"],
						questionSet.options["puzzleHeight"],
						questionSet.options["spots"],
						questionSet.options["wordLocations"],
						getWords());
				_wordSearchGameDisplay = new WordSearchDisplay();
				_wordSearchGameDisplay.displayPuzzle(_wordSearchGameData);
				wordSearchSWFLoader.source = _wordSearchGameDisplay;
				_wordSearchGameDisplay.completePuzzle(_wordSearchGameData);
			}
			else
			{
				generatePuzzleDisplay(); // generate with the new words
			}
			btnGenerate.enabled = true;
		}

		public override function onSaveClicked(mode:String = 'save'):void
		{
			if(checkQSetErrors() && checkWordSearch())
			{
				var q:QuestionGroup = generateQSET();
				validateQIDs(q);

				var qset_object:Object = q.convertToObject()

				// scrub out any error messages stored in the qset *HACK
				for (var i:* in qset_object.items)
				{
					var question:Object = qset_object.items[i];
					for (var id:String in question.options)
					{
						if (id == 'errorMessage' || id == 'errorTitle')
						{
							delete question.options[id];
						}
					}
				}


				ExternalInterface.call("__materia_flash_save", instanceTitle, qset_object, questionSetVersion);
			}
		}

		/**
		 * Check and alert any QSet errors
		 * ex: invalid question or answers
		 * Returns false if errors present, true otherwise
		 **/
		public function checkQSetErrors():Boolean
		{
			var error:Object;
			// Errors from individual questions
			var qsetErrors:Array = getQSetErrors();
			// No QSet errors
			if(!qsetErrors)
			{
				return true;
			}
			// Alert first error
			error = qsetErrors.shift().question.options;
			Alert.show(error.errorMessage, error.errorTitle);
			return false;
		}
		public function getQSetErrors():Array
		{
			// Object is undefined, returns false if no errors
			var errors:Array;
			// Ignore last data provider (placeholder)
			for(var i:int = 0; i < questionsDataGrid.dataProvider.length-1; i++)
			{
				// DataProvider is an array of TextInputObjects
				// Word search only has answers visible
				if(!questionsDataGrid.dataProvider[i].question.validAnswer())
				{
					if(errors == null)
					{
						errors = new Array();
					}
					errors.push(questionsDataGrid.dataProvider[i]);
				}
			}
			return errors;
		}
		/**
		 * Check and alert any word search errors ex: puzzle is not generated
		 * Not called before puzzle is generated (should not alert missing puzzle when trying to generate the puzzle!)
		 * Returns false if found errors, true otherwise
		 **/
		public function checkWordSearch():Boolean
		{
			// Crossword errors (ex. puzzle not generated)
			var error:Object = getWordSearchError();
			// No errors
			if(!error)
			{
				return true;
			}
			// Alert error
			Alert.show(error.errorMessage, error.errorTitle);
			return false;
		}
		/**
		 * Gets Non-QSet related errors
		 * ex: Crossword not generated
		 **/
		public function getWordSearchError():Object
		{
			// Object is undefined, returns false if no errors
			var error:Object;
			if(!_puzzleGenerated)
			{
				error = new Object();
				error.errorMessage = "Your word search has not yet been generated.";
				error.errorTitle = "Missing Puzzle";
			}
			return error;
		}

		protected function generateQSET():QuestionSet
		{
			var qset:QuestionSet = new QuestionSet();
			var group:QuestionGroup = questionsDataGrid.generateQGroup();
			var i:int;

			var items:Array = group.items;

			for (i = 0; i < items.length; i++)
			{
				//Skip any empty items
				if (String(items[i].answers[0].text).length != 0)
				{
					//Copy answer over to question (for better display in scores screen)
					items[i].questions[0].text = items[i].answers[0].text;
					qset.addChild(items[i]);
				}
				
			}
			// add the game options
			qset.options["backwards"] = backwardsCheckBox.selected;
			qset.options["diagonal"] = diagonalCheckBox.selected;
			qset.options["random"] = randomCheckBox.selected;
			qset.options["byDefinitions"] = _isEnterByDefinition;
			if (randomCheckBox.selected == false && _wordSearchGameData != null)
			{
				qset.options["puzzleWidth"] = _wordSearchGameData.puzzleSpots[0].length;
				qset.options["puzzleHeight"] = _wordSearchGameData.puzzleSpots.length;
				qset.options["spots"] = _wordSearchGameData.getPuzzleSpotsString();
				qset.options["wordLocations"] = _wordSearchGameData.getFinalWordPositionsString();
			}
			validateQIDs(qset); // make sure it is right to send the qids we are sending
			return qset;
		}
		/**
		 *	Called once for each question that was selected to be imported.
		 */
		public override function addImportedQuestion(question:Question):Question
		{
			var q:Question = super.addImportedQuestion(question);
			questionsDataGrid.addQuestion(q, false);
			return q;
		}
//		public override function getImportableQuestionTypes():Array
//		{
//			return [QUESTION_ANSWER, MULTIPLE_CHOICE];
//		}
		//---------------------------------------------------------------------
		// End of overriden methods
		//---------------------------------------------------------------------
		protected function onItemEditEnd(e:Event):void
		{
			if (_listDataChanged == true)
			{
				generatePuzzleDisplay();
			}
		}
		protected function onListDataChanged(e:Event):void
		{
			_listDataChanged = true;
			_refreshTimer.reset();
			_refreshTimer.start();
			if (_questionData.length > 1)
			{
				btnGenerate.enabled = true;
			}
		}
		protected function generatePuzzleDisplay(e:Event = null):void
		{
			_listDataChanged = false;
			_refreshTimer.reset();
			var words:Array = getWords();
			if (words.length < 1)
			{
				_puzzleGenerated = false;
				return;
			}
			_wordSearchGameData = new WordSearchLogic(1, 1, diagonalCheckBox.selected, backwardsCheckBox.selected);
			_wordSearchGameData.makePuzzle(words);
			_wordSearchGameDisplay = new WordSearchDisplay();
			_wordSearchGameDisplay.displayPuzzle(_wordSearchGameData);
			wordSearchSWFLoader.source = _wordSearchGameDisplay;
			_wordSearchGameDisplay.completePuzzle(_wordSearchGameData);
			_puzzleGenerated = true;
		}
		public function getWords():Array
		{
			var words:Array = [];
			for (var i:int = 0; i < _questionData.length; i++)
			{
				var str:String = stripSpacesAndLowerCase(_questionData.getItemAt(i).question.answer);
				if (str.length > 0)
				{
					words.push(str);
				}
			}
			return words;
		}
		protected function stripSpacesAndLowerCase(s:String):String
		{
			//make all lowercase
			s = s.toLowerCase();
			//strip of all characters other than alphabet and numbers
			var i:int;
			for (i = 0; i < s.length; i++)
			{
				if (s.charCodeAt(i) > 122 || (s.charCodeAt(i) > 57 && s.charCodeAt(i) < 97) || s.charCodeAt(i) < 48)
				{
					s = s.substring(0, i).concat(s.substring(i + 1));
					i--;
				}
			}
			return s;
		}
		protected function backwardsCheckBoxChecked():void
		{
			generatePuzzleDisplay();
		}
		protected function diagonalCheckBoxChecked():void
		{
			generatePuzzleDisplay();
		}
		protected function randomBoxChecked():void
		{
			if (randomCheckBox.selected)
			{
				sWFBackgroundCanvas.alpha = .7;
				wordSearchSWFLoader.alpha = .7;
			}
			else
			{
				sWFBackgroundCanvas.alpha = 1;
				wordSearchSWFLoader.alpha = 1;
			}
		}
		protected function toggleEntryMode():void
		{
			if (_currentEntryMode == 0)
			{
				enterByDefinition();
			}
			else
			{
				enterByTerms();
			}
		}
		protected function enterByTerms():void
		{
			_isGameTypeSelected = true;
			_isEnterByDefinition = false;
			gameTypeExplanationVBox.visible = false;
			currentTermsLabel.text = "Using Terms Only";
			currentTermsLabel.toolTip = "You will input a list of terms and clues for finding the terms. Students will search for the terms using only clues";
			_currentEntryMode = 0;
		}
		protected function enterByDefinition():void
		{
			_isGameTypeSelected = true;
			_isEnterByDefinition = true;
			gameTypeExplanationVBox.visible = false;
			currentTermsLabel.text = "Using Terms & Clues";
			currentTermsLabel.toolTip = "You will input a list of terms which students will search for in the letter grid.";
			_currentEntryMode = 1;
		}
		]]>
	</mx:Script>
</materia:CreatorBase>